;; 2021-02-27
(defn go-again []
  (print "Go again?")
  (flush)
  (let [user-answer (if (= (read-line) "y")
                      true
                      false)]
    (printf "%s\n" user-answer)
    user-answer))

(defn user-input [fn-name]
  (let [fn-result (fn-name)]
    (printf "user-input fn-name: %s returns: %s\n" fn-name fn-result)
    (if (boolean? fn-result)
      fn-result
        (do
          (print "Function" (str fn-result) ": ")
          (flush)
          (let [user-answer (if (= (read-line) "y")
                              true
                              false)]
            (printf "%s\n" user-answer)
            user-answer)))))

;; Loop through tests (nth curr 0) while tests are false, until hitting wait.
;; Stop looping  if test is true, and change to the next-state-edge (nth curr 2).
(defn traverse-debug
  [state]
  (cmgr.state/add-state :test-mode)
  ;; (printf "state=%s\n" state)
  (if (nil? state)
    nil
    (loop [tt (state cmgr.state/table)
           xx 1]
      (let [curr (first tt)
            test-result (user-input (nth curr 0))]
        ;; (printf "curr=%s\n" curr)
        (if (and test-result (some? (nth curr 1)))
          (traverse-debug (nth curr 1))
          (if (seq (rest tt))
            (recur (rest tt) (inc xx))
            nil))))))

;; 2021-02-16
;; If test-result and there is a new state, go to that state. When we return, we're done.
;; Otherwise go to the next function of this state (regardless of the truthy-ness of a test or function return).
;; Always stop when we run out of functions.
;; todo? Maybe stop when the wait function runs. Right now, wait is a no-op.

(defn traverse
  [state]
  (if (nil? state)
    nil
    (loop [tt (state cmgr.state/table)]
      (let [curr (first tt)
            test-result ((nth curr 0))]
        (if (and test-result (some? (nth curr 1)))
          (traverse (nth curr 1))
          (if (seq (rest tt))
            (recur (rest tt))
            nil))))))

;; (if-arg :item) Do not clear state after testing it, even if it might prevent infinite loops. The wrongness
;; of clearing state can be seen by the wrongness of resetting :logged-in. Infinite loops need to be addressed
;; by proper design and good logic.
(defn if-arg
  ([tkey]
   (if-arg tkey nil))
  ([tkey side-effect]
   (if (:test-mode @app-state)
     tkey
     (let [tval (tkey @params)
           ret (and (seq tval) tval)]
       (when (and ret side-effect) (side-effect))
       ret))))

;; This is not entirely accurate and will report false positive infinite loops. See the machine git repo.
(defn traverse-all
  [state table]
  (printf "state=%s\n" state)(flush)
  (if (nil? state)
    nil
    (loop [tt (state table)]
      (swap! limit-check inc)
      (let [curr (first tt)]
        ;; Assume tests are true, but when we return, continue as though the test was false.
        ;; Default to nil from (nth curr 1) in case there aren't 2 elements. We require 2 elements,
        ;; but that requirement should be covered by other code. 
        (when (some? (nth curr 1 nil))
          (do
            (prn "new state: " (nth curr 1))
            (traverse-all (nth curr 1) table)
            (print (format "returning to state: %s\n" curr))))
        (if (and (< @limit-check limit-max) (seq (rest tt)))
          (do 
            (printf "lc: %s and: %s\n" @limit-check (and (< @limit-check 15) (seq (rest tt))))
            (flush)
            (recur (rest tt)))
          (do
            (if (>= @limit-check limit-max)
              (printf "Stopping at limit-check %s. Infinite loop?\n" @limit-check)
              (printf "Clean exit at limit-check %s. Apparently this machine halts.\n" @limit-check))
            nil))))))

(defn verify-table [table]
  (let [states (set (keys table))
        next-states (set (filter keyword? (flatten (vals table))))]
    (if (= next-states states)
      (format "All defined/called match.\n")
      (if (clojure.set/subset? next-states states)
        {:msg (format "Edges that are never called: %s\n" (str/join " " (clojure.set/difference states next-states)))
         :fatal false}
        {:msg (format "Undefined edges: %s\n" (str/join " " (clojure.set/difference next-states states)))
         :fatal true}
        ))))

(defn check-table [table]
  (let [arity-problems (filter #(not= 2 (count %)) (mapcat identity (vals table)))]
    (when (some? arity-problems)
      (doseq [edge arity-problems]
        (printf "Expecting 2 elements in edge: %s\n" edge)))))

(def limit-check (atom 0))
(def ^:dynamic limit-max 17)



;; prior to 2021-02-27

;; A "site" is all the pages with the same site_name.
(comment
  (cmgr.core/init-config)
  (do (reset! params {:site_name "hondavfr"})
      (site_gen)
      (reset! params {:site_name "hondavlx"})
      (site_gen))
  )


;; Historically, we converted any 4 control characters (newlines) convert to <br><br> tags 
;; when saving, and converted the other way when reading from the db and rendering in HTML.
;; Bad idea. Just leave them as newlines and convert only when necessary for html, which is not in a <textarea> tag.
;; (let [desc (str/replace (:description @params) #"([\000-\037]{4})" "<br><br>")]
;;   (swap! params #(assoc % :description desc))



(defn next_content_page [] 
  ;; do_sql_simple("hondavfr", "", "select con_pk from content where page_fk=\$page_pk and valid_content<>0 and item_order>\$item_order order by item_order asc limit 1");
  ;; if ($con_pk)
  ;; {
  ;;     $edit = 1;
  ;; }
  ;; else
  ;; {
  ;;     $done = 1;
  ;; }
  (let [result-set (jdbc/execute-one!
                    ds-opts
                    ["select con_pk from content where page_fk=? 
			and valid_content<>0 and item_order>? order by item_order asc limit 1" (:page_pk @params)])]))


;; 2021-02-13 if you wanted ring to serve the resulting static html, you would probably need something like
;; this to handle making index.html the default. Probably add it after the other handlers.
;; We are not currently using ring to serve static pages created by the content manager.
(defn wrap-dir-index [handler]
  (fn [req]
    (handler
     (update-in req [:uri]
                #(if (= "/" %) "/index.html" %)))))


;; Used here to serve static content, and used in cmgr.state to know where to export the generated web pages.
(def export-path (str(System/getenv "HOME") "/Sites/content-manager-pages"))


(comment
  (let [request {:params {"d_state" "page_search"
                          "findme" "foo"
                          "ginfo" "content_manager,twl"
                          "page_pk" "2030"
                          "item" "Edit content"}}
        tp (as-> request yy
             (:params yy)
             (reduce-kv #(assoc %1 (keyword %2) (clojure.string/trim %3))  {} yy)
            (assoc yy :d_state (keyword (:d_state yy)))
            )]
  tp)
  )


;; run!
;; (reduce #(proc %2) nil coll)
;; run! with index
(comment
  (let [site_path "foo-path"
        mfn (fn [sp xx dex] (prn sp xx dex)) ]
    (reduce #(let [xx %2
                   dex %1]
               (mfn site_path xx dex)
               (inc dex)) 1 [4 5 6 7]))
  )



;; (get_wh "/Users/twl/Sites/content-manager-pages/hondavfr/images/vfr/vfr1.jpg")
;; (get_wh "/Users/twl/Sites/content-manager-pages/hondavfr/images/vfr/vfr1_s.jpg")
;; (get_wh "/Users/twl/Sites/content-manager-pages/1990_f250/images/f250/IMG_1142.JPG")
;; (get_wh "/Users/twl/Sites/content-manager-pages/1990_f250/images/f250/IMG_1142_s.JPG")
;;  full_name "/Users/twl/Sites/content-manager-pages/1990_f250/images/f250/IMG_1142.JPG"


(comment
  (jdbc/execute! ds-opts ["select description from content limit 1"])
  (jdbc/execute! ds-opts ["select con_pk,page_fk from content where valid_content=1 limit 5"])
  (jdbc/execute! ds-opts ["select count(*) from content where page_fk is null"])
  )

(comment
  ;; remove leading "images/" from page.image_dir
  (let [result-set (jdbc/execute!
                    ds-opts
                    ;; ["update page set image_dir='images/home' where page_pk=4280"]
                    ;; ["select * from page where page_pk=539"]
                    ["select * from page"]
                    )
        update-set (mapv #(assoc % :image_dir (str/replace (:image_dir %) #"images/" "")) result-set)]
    (doseq [uprec update-set]
      (println "updating: " (:page_pk uprec))
      (sql/update! ds-opts :page uprec {:page_pk (:page_pk uprec)}))
    )
  ;; update page set image_dir="images/home" where page_pk=4280;

  (let [result-set (jdbc/execute-one!
                    ds-opts
                    ["select page_fk,
		      	image_name, image_width, image_height,
		      	description, alt_text, valid_content,
		      	item_order, s_name, s_width, s_height,
		      	template, menu, page_title, body_title,
		      	page_name, search_string, site_name, site_path,
		      	page_order, valid_page, image_dir, external_url
		      	from content,page where con_pk=? and page_fk=page_pk"
                     2032])
        ready-data (merge @params
                          result-set
                          {:drows 20
                           :page_pk (:page_fk result-set)
                           :d_state "edit_item"})
        html-result (clostache/render (slurp "html/edit_item.html") ready-data)]
    (reset! html-out html-result)
    (prn "ready-data: " ready-data)
    )
  )

(comment
  ;; con_pk 2032 page_pk 2030
  (jdbc/execute!
   ds-opts
   ["select content.*, page.image_dir, page.site_path from content,page where page_fk=? and page_pk=page_fk order by item_order"
    2030])
  (jdbc/execute-one! ds-opts ["select con_pk,image_dir,site_path from content,page where page_pk=page_fk and image_dir is not null"])
  (jdbc/execute-one! ds-opts ["select con_pk,image_dir,site_path from content,page where page_pk=page_fk and con_pk=2032"])
  )

(comment 
  ;; returns a string, not a number.
  (format "%1.0f" (/ (count ordinal-set) desired-columns))
  (quot (+ 14 5) 5.0)
  (quot 14 5.0)
  ;; seems to reliably return the number we expect
  (quot (+ 0.5 (/ 13 5.0)) 1)
  (rem (+ 14 0) 5.0)
  (sort-by :ordinal foo)
  (map (fn [xx] [(:page_break xx) (mod (:ordinal xx) 3)]) foo)
  (sort-by :ordinal [{:foo 1 :ordinal 2} {:foo 3 :ordinal 0}])
  
  (map (fn [xx] (mod (inc xx) 3)) (range 15))
  )

(def old-app
  (wrap-file (wrap-multipart-params (wrap-params handler)) "/Users/twl/Sites/content-images"))




  ;; convert <br><br> in content.description to \n\n\n\n
  (let [descs (jdbc/execute! ds-opts ["select con_pk,description from content where description is not null"])
        _ (prn (count descs))
        good-descs (mapv #(assoc % :description (str/replace (:description %) #"<br><br>" "\n\n\n\n")) descs)]
    (doseq [uprec good-descs]
      (println "updating: " (:con_pk uprec))
      (sql/update! ds-opts :content uprec {:con_pk (:con_pk uprec)})
      )
   )



(comment
  (def rsa (jdbc/execute-one! ds-opts ["select * from page where page_pk=?" 4237]))
  ;;   :page_pk = 4237

  (def rsx (jdbc/execute-one! ds-opts ["select * from page where page_pk=?" 4237]))

  (reset! params (assoc rsa :page_title "Tom's Baja: Heater Blower"))

  ;; does not work
  (def rsb  (apply
             jdbc/execute-one!
             [ds-opts
              ["update page set template=?, menu=?, page_title=?, body_title=?, page_name=?, search_string=?, image_dir=?, site_name=?, site_path=?, page_order=?, valid_page=?, external_url=? where page_pk=?"
               (map @params [:template :menu :page_title :body_title :page_name :search_string :image_dir :site_name :site_path :page_order :valid_page :external_url :page_pk])]]))

  (def rsu (sql/update! ds-opts
                        :page
                        (select-keys @params [:template :menu :page_title :body_title :page_name :search_string :image_dir :site_name :site_path :page_order :valid_page :external_url :page_pk])
                        {:page_pk (:page_pk @params)}))

  (def rsb  (jdbc/execute-one!
             ds-opts
              ["update page set page_title=? where page_pk=?"
               (:page_title @params) (:page_pk @params)]))

  (defn myfn [xx yy] (str xx yy))
  (apply myfn (select-keys @params [:template :menu]))
  )


  (def foo 
    [["r850r" "aa" "fuel_pump_connector.html" 4219 8.1]
     ["r850r" "aa" "review.html" 4233 9.0]
     ["sorghum" "bb" "index.html" 4287 1.0]
     ["trucks" "cc" "index.html" 4280 1.0]
     ["trucks" "cc" "bench_seat.html" 4281 2.0]
     ["trucks" "cc" "f250_window.html" 4282 3.0]
     ["volkswagen" "dd" "index.html" 3982 1.0]
     ["volkswagen" "dd" "golf_headlight.html" 3996 2.0]
     [ "volkswagen" "dd" "golf_battery.html" 4271 3.0]])

  ;; Create a list of hashes where keys are the field names
  (def bar (map #(apply zipmap [[:site_name :x_var :page_name :page_pk :page_order] %]) foo))

  ;; Create a list of lists [[site1 [pages]] [site2 [pages]] ...]
  (group-by (juxt :site_name :x_var) bar)

(comment
  ;; Simpler because it relies on ds-opts having with-options
  (def foo (jdbc/execute! ds-opts
                          ["select * from page where site_name=? limit 3" "hondavfr"]))

  ;; alternate stuff that works
  ;; https://github.com/seancorfield/next-jdbc/blob/develop/doc/getting-started.md

  ;; ds is clearly a "datasource"
  (def ds (jdbc/get-datasource db))
  (def foo (jdbc/execute! ds ["select * from page limit 1"]))

  (def foo (jdbc/execute! ds
                          ["select * from page limit 2"]
                          {:return-keys true :builder-fn rs/as-unqualified-maps}))

  (def foo (jdbc/execute! ds
                          ["select * from page where site_name=? limit 1" "hondavfr"] 
                          {:return-keys true :builder-fn rs/as-unqualified-maps}))

  (def foo (jdbc/execute! ds
                          ["select * from page where site_name=? limit 1" "hondavfr"] 
                          {:return-keys true :builder-fn rs/as-unqualified-maps}))
  )


(comment
  (def foo
    (let [result-set (jdbc/execute! ds-opts
                                    ["select * from page where valid_page=1 limit 2"])
          ready-data
          (merge {:recordsfound 1
                  :s ""
                  :template "page_search.html"
                  :d_state "d state"
                  :findme_encoded "foo"}
                 {:dcc_site (mapv (fn [xx] {:site_name (key xx)
                                            :dcc_page (val xx)}) (group-by :site_name result-set))})]
      (spit "tmp.html"
            (clostache/render
             (slurp "html/page_search.html")
             ready-data))
      (def rd ready-data)
      )
    )

  (def bar (jdbc/execute! ds-opts ["select * from page where valid_page=1 limit 2"]))
  (group-by  (fn [xx] {:site_name (:site_name xx) :dcc_page xx}) bar)

  (clostache/render
   "stuff {{#dcc_site}} site_name: {{site_name}} {{#dcc_page}} page_name: {{page_name}} {{/dcc_page}} {{/dcc_site}} end"
   {:dcc_site [{:site_name "hondavfr" :dcc_page [{:page_name "intro"}{:page_name "cases"}]} {:site_name "bug"}]})

  (clostache/render
   "stuff {{#dcc_site}} site_name: {{site_name}} {{#dcc_page}} page_name: {{page_name}} {{/dcc_page}} {{/dcc_site}} end"
   rd)
  {:recordsfound 1 :dcc_site (map (fn [xx] {:site_name (key xx) :dcc_page (val xx)}) (group-by :site_name bar))}
  )
